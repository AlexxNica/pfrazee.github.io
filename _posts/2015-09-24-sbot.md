---
layout: post
title: The Scuttlebot P2P Database
desc: Beta 1 release announcement.
---

<style>
hr { margin: 2em 0; border: 0; border: 1px solid #ccc; }
img { vertical-align: middle; max-width: 100%; }
</style>

> **Good news! The [Scuttlebot P2P database beta 1](https://github.com/ssbc/scuttlebot) is now available.**

> [Secure Scuttlebutt](https://github.com/ssbc/secure-scuttlebutt) is a P2P database protocol created by [Dominic Tarr](https://twitter.com/dominictarr).
It started as a small spec and a library which wrapped LevelDB.
A year ago I joined Dominic on the project, and today we're ready to release beta 1 of the [Scuttlebot P2P database](https://github.com/ssbc/scuttlebot).

![Hermies the Hermit Crab](https://avatars2.githubusercontent.com/u/10190339?v=3&s=200)
*It's distributed!*

## The Challenge with P2P

Peer-to-peer, decentralized applications are hard to write.
Why?

 - **Availability.** Users' devices turn on and off all the time. Managing connection life-cycles while providing a good user-experience takes a lot of work. NAT and firewalls make this even harder.
 - **Data Consistency.** Without a single authority, it's easy for state to go out-of-sync between computers. If that happens, fixing the network without data-loss is extremely difficult.
 - **Data Integrity.** The problem of data-consistency is even worse in an attacker scenario. Ensuring peers don't lie to each other is key. (That includes dropping and re-ordering messages.)
 - **Spam-prevention.** Spam is a fundamental problem in an open network (like email). A good network needs to let users participate freely, but stop noise from overwhelming the system.
 - **Confidentiality.** Encryption depends on certificate distribution, which is not an adequately-solved problem in global p2p networks.

Wouldn't it be great if your database handled all that for you?
That's the idea here.

**Scuttlebot is a general-purpose EC database for P2P, decentralized applications.**
It's designed for desktops and servers, and supports a wide variety of apps: photo- and file-sharing, encrypted messaging, office productivity, knowledge bases, etc.

Scuttlebot solves the hard problems underlying P2P so developers can focus on data and applications.
It gives desktop software the same kind of connectivity you'd expect from the Web, but with end-to-end confidentiality and no host dependency.

Let's dive into the details of the protocol and architecture.

---

## Secure Scuttlebutt

**Secure Scuttlebutt (SSB)** is a P2P database protocol of message-feeds.
It consists of

- Per-user append-only logs of messages (i.e. [kappa architecture](http://www.kappa-architecture.com/))
- Content-addressable storage (i.e. `obj.id == hash(obj)`)
- Message distribution over a [gossip network](https://en.wikipedia.org/wiki/Gossip_protocol)

[Scuttlebot](https://github.com/ssbc/scuttlebot) is an SSB server.
It provides the SSB log database, a networked blob-store, the gossip protocol, and a CLI and RPC interface.


### Data Structures

Intuitively, you can think of SSB as structured like Twitter.
All data is structured into _Feeds_, _Messages_, and _Blobs_.
A Message is a single post, and a Feed is an ordered log of messages.
A Blob is textual or binary data referenced in a message (similar to an email attachment).

Messages contain the ID of the feed they are in, the hash of the previous message, some arbitary JSON content (or an encrypted base64 string), and a signature.
Because each message is signed, anyone can verify that a given message belongs to a particular Feed.

### Links

Messages, feeds, and blobs are addressable by specially-formatted identifiers.
Message and blob IDs are content-hashes, while feed IDs are public keys.

To indicate the type of ID, a "sigil" is prepended to the string. They are:

 - `@` for feeds
 - `%` for messages
 - `&` for blobs

Additionally, each ID has a "tag" appended to indicate the hash or key algorithm.
Some example IDs:

 - A feed: `@LA9HYf5rnUJFHHTklKXLLRyrEytayjbFZRo76Aj/qKs=.ed25519`
 - A message: `%MPB9vxHO0pvi2ve2wh6Do05ZrV7P6ZjUQ+IEYnzLfTs=.sha256`
 - A blob: `&Pe5kTo/V/w4MToasp1IuyMrMcCkQwDOdyzbyD5fy4ac=.sha256`

When IDs are found in the messages, they are treated as links, with the keyname acting as a "relation" type.
SSB automatically builds an index based on these links, to allow queries such as "all messages with a `mentions` link to this user."


### Message Content

Messages and links in SSB are typed, but SSB doesn't try to impose any validation or schemas.
Each message is a simple JSON object:

```js
{
   type: 'post', // the only required field
   text: 'Hello, @alice!',
   mentions: [{
      link: '@hxGxqPrplLjRG2vtjQL87abX4QKqeLgCwQpS730nNwE=.ed25519',
      name: 'alice'
   }]
}
```

This is a `post`-type message with a `mentions`-type link.
Scuttlebot creates indexes on these types.
Interpretation and validation is left to the applications, per the [Kappa Architecture](http://www.kappa-architecture.com/).

Each user maintains a separate log, and each log is an ordered list of these messages.
Scuttlebot [provides an API](https://github.com/ssbc/docs/blob/master/intro-to-using-sbot.md) for querying and streaming these logs.


### Data Consistency

SSB is [Eventually Consistent](https://en.wikipedia.org/wiki/Eventual_consistency), which means the local node always accepts writes, and changes are synced to the network afterwards.
To make sure the network converges to the correct state, SSB uses the append-only log CRDT (the feeds).
Each feed maintains its own total order, and uses the message links to create global partial orders.


### Data Integrity

The append-only constraint for feeds is enforced with a blockchain structure: each entry includes the hash of the previous message.
If a peer receives a message with a `previous` hash that doesn't match the local cache, it'll reject the offending message.
Logs which violate this constraint risk creating two histories in the network which can't be reconciled, and therefore losing the ability to make progress in the network.


### Availability

SSB uses a [gossip network](https://en.wikipedia.org/wiki/Gossip_protocol) to solve the availability problem.
Gossip distributes messages across multiple machines, without requiring direct connections between them.

![Gossip graph](/img/gossip-graph1.png)

Even though Alice and Dan lack a direct connection, they can still exchange feeds:

![Gossip graph 2](/img/gossip-graph2.png)

This is because gossip creates "transitive" connections between computers.
Dan's messages travel through Carla and the Pub to reach Alice, and visa-versa.
Because all feeds are signed, if Dan has confirmed Alice's pubkey, then Dan doesn't have to trust Carla *or* the Pub to receive Alice's messages from them.

Scuttlebot automatically discovers LAN peers and syncs with them.
"Pubs" are public nodes that help us get around [NAT](https://en.wikipedia.org/wiki/Network_address_translation) and firewalls.
They aren't hosts, and have no special privileges, but they are often required to get global connectivity.
In a LAN, they're not needed.


### Spam-prevention and Trust

To prevent spam, users need a way to signal interest in each others' messages.
SSB uses the social-networking concept of "following" to explicitly select the feeds to sync during gossip.

Follows are published on users' feeds, as a public trust-signal.
Blocks can also be published, to stop users from sending or receiving messages to/from the blocker.
Graph analysis can be applied on this friend network to discover and isolate spammers, moderate messages, and improve content-discovery.

In addition to signalling trust, publishing "follows" has the added advantage of distributing the pubkey IDs of the followed users.
This feeds into the confidentiality system.


### Confidentiality 

For private sharing, Scuttlebot uses [libsodium](http://doc.libsodium.org/) to encrypt confidential information.
Feed IDs are public keys, and so once two feeds are mutually following each other, they can exchange confidential data freely.

Encryption is applied to all connections using the [secret handshake](https://github.com/dominictarr/secret-handshake) protocol.
This protocol claims to be metadata-secure to unauthenticated actors, so that the identities of the connectors are only revealed if the pubkeys are known a-priori.

SSB can encrypt feed messages to provide end-to-end confidentiality.
The [private-box](https://github.com/auditdrivencrypto/private-box) algorithm claims to hide all content and recipient metadata from observers.
Currently this is limited to 7 other recipients.


### SSB Compared to Other Protocols

SSB shares some features with Bitcoin, including the use of a blockchain, but it does not use Proof-of-Work.
This is because Bitcoin shares one blockchain with many users, while SSB gives one blockchain to each user.
(SSB's feeds are blockchains.)

Unlike BitTorrent or [IPFS](https://ipfs.io/), SSB does not maintain a distributed hash-table.
Instead, it uses a gossip protocol which syncs regularly with all known peers.
SSB is also more focused on syncing application data, while BitTorrent and IPFS focus on file-exchange.

---

## Using Scuttlebot

Scuttlebot is a [Kappa architecture](http://www.kappa-architecture.com/), which is a simple but relatively unfamiliar database design.
Applications query the message-logs, and process the messages into "materialized views," which are basically snapshots of the state.

The advantage of materialization is it allows you to change the data model without changing the data.
The logs remain permanent sources of truth, while you tweak the view-processing functions to extract new information.
Your logs' message-schemas can evolve over time, but you don't have to lose data if your materializers stay backwards compatible.

Let's look at a few example apps.


### Blessed Dashboard

The [Blessed Dashboard](https://github.com/pfraze/ssb-blessed-dashboard) is a very simple explorer that does little materialization.
Instead, it uses Scuttlebot's API to create "raw" views of the data feeds.

**[Learn more in the README.](https://github.com/pfraze/ssb-blessed-dashboard)**


### Example Whois

[Example Whois](https://github.com/pfraze/ssb-example-whois) shows how to do materialization by constructing a mapping of petnames to feed-IDs.
It does this by looking at the `type: about` messages, and ranking them by the local users' follow-graph.

**[Learn more in the README.](https://github.com/pfraze/ssb-example-whois)**


### Private Message

[Private Message](https://github.com/pfraze/ssb-pm) shows how to publish encrypted messages.
It publishes `type: post` messages that are encrypted for the sender and a specific recipient.
It shows how to decrypt messages in the "inbox" view.

**[Learn more in the README.](https://github.com/pfraze/ssb-example-pm)**

---

## Project Links

Scuttlebot includes a lot of novel software by Dominic, including [pull-streams](https://github.com/dominictarr/pull-streams), [a lightweight RPC library](https://github.com/ssbc/muxrpc), and [a capabilities-based secure channel protocol](https://github.com/dominictarr/secret-handshake).

**Getting Started: If you want to see what the API is like, see the [Introduction to using and developing with Scuttlebot](https://github.com/ssbc/docs/blob/master/intro-to-using-sbot.md)** You can also find the [main repo here](https://github.com/ssbc/scuttlebot).

Join us in #scuttlebutt on freenode.

Cheers. [-pfraze](https://twitter.com/pfrazee)
